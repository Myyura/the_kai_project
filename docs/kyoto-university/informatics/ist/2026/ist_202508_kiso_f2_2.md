---
sidebar_label: "2025年8月実施 情報学基礎 F2-2"
tags:
  - Kyoto-University
---
# 京都大学 情報学研究科 知能情報学専攻 2024年8月実施 情報学基礎 F2-2

## **Author**
[itsuitsuki](https://github.com/itsuitsuki)

## **Description (English)**
Fig. 1 shows a weighted undirected graph $G$. The vertex set of $G$ is $V = \{a, b, c, d, e, f\}$, and the edge set of $G$ is $E = \{(a, b), (a, c), (a, e), (b, c), (b, d), (d, e), (d, f), (e, f)\}$. For each edge $(u, v) \in E$, the order of $u$ and $v$ is not distinguished. In Algorithms 1 and Algorithm 2, $V$ and $E$ are referred to as $G.V$ and $G.E$, respectively. The weight $w(u, v)$ of each edge in $G$ is given in Fig. 1. A minimum spanning tree of $G$ is a connected subgraph that contains all vertices in $G$, has no cycles, and minimizes the total weight of its edges.

<figure style="text-align:center;">
  <img src="https://raw.githubusercontent.com/Myyura/the_kai_project_assets/main/kakomonn/kyoto_university/informatics/ist_202508_kiso_f2_2_p1.png" width="400" alt=""/>
</figure>

### Q.1
Answer the following questions.

(1) List all the edges of the minimum spanning tree of $G$, and answer the total weight of those edges.

(2) Suppose that a cut $(S, V - S)$ of $G$ is defined by the vertex set $S = \{d, f\}$. List all the edges between $S$ and $V - S$.

(3) Prove by contradiction that the edge $(b, d)$ is included in the minimum spanning tree of $G$.

### Q.2
Prim's algorithm is a greedy method for constructing a minimum spanning tree. The algorithm starts from an arbitrary root $r \in V$ and grows the tree by iteratively selecting edges with the smallest weights $w(u, v)$, until the tree includes all vertices in $V$. To select the next vertex to add, the algorithm manages the vertices using a min-priority queue $Q$. Each vertex $v \in V$ in the queue has an attribute $v.key$, which stores the weight of the smallest edge weights between $v$ and the tree. For each step, the vertex with the smallest $key$ is extracted from $Q$ and added to the tree. The parent of a vertex $v$ in the tree is denoted by $v.parent$. Answer the following questions about this algorithm.

(1) Complete Algorithm 1: MST-PRIM, which shows the pseudo-code for Prim's algorithm, by filling in the blanks $\fbox{(a)}$ and $\fbox{(b)}$. In Algorithm 1, $Q$ denotes the set of vertices stored in the min-priority queue. The following operations are used:
+ $\textsc{Insert}(Q, u)$ inserts a vertex $u$ into $Q$.
+ $\textsc{Extract-Min}(Q)$ removes and returns the vertex in $Q$ that has the smallest $key$.
+ $\textsc{Decrease-Key}(Q, v, w(u, v))$ updates the value of $v.key$ to $w(u, v)$ for vertex $v$ in $Q$.
Assume that the priority queue $Q$ maintains its order so that the vertex with the smallest $key$ can always be extracted without searching. This reordering is performed after each of the operations $\textsc{Insert}$, $\textsc{Extract-Min}$, and $\textsc{Decrease-Key}$.

<figure style="text-align:center;">
  <img src="https://raw.githubusercontent.com/Myyura/the_kai_project_assets/main/kakomonn/kyoto_university/informatics/ist_202508_kiso_f2_2_p2.png" width="400" alt=""/>
</figure>

(2) Suppose that Algorithm 1 is applied to the graph $G$ with $r = d$. List all the vertices $v$ remaining in $Q$ at the end of each iteration of the while loop as pairs $(v, v.key)$, sorted in ascending order of $key$. In the answer, write each state of $Q$ on a separate line, in execution order, until $Q = \emptyset$. If multiple vertices have the same $key$, list them in alphabetical order.
The state of $Q$ just before entering the while loop is as follows (do not include this in your answer):
$$
(d, 0), (a, \infty), (b, \infty), (c, \infty), (e, \infty), (f, \infty) 
$$

(3) Answer the asymptotic upper bound of the worst-case running time when Algorithm 1 is executed on the graph $G = (V, E)$. Use the Big-O notation and express the answer using $|V|$ and $|E|$, where $|\cdot|$ denotes the number of elements in a set. Assume that the reorganization of the priority queue associated with each of the operations $\textsc{Insert}$, $\textsc{Extract-Min}$, and $\textsc{Decrease-Key}$ takes $O(|V|)$ time. Answer with the smallest order.

### Q.3
Kruskal's algorithm derives a minimum spanning tree by sequentially adopting an edge that does not generate a cycle, in ascending order of edge weight. Algorithm 2 shows a pseudo-code of Kruskal's algorithm in which Union-find algorithm is used to evaluate whether a cycle is generated by the selected edge. Union-find can efficiently check whether two elements belong to the same set by expressing a set with a tree structure. Answer the following questions.

(1) Suppose that Kruskal's algorithm is applied to the graph $G$ with the weights $w$ shown in Fig. 1. Show the edges composing the obtained minimum spanning tree in order of being adopted. If there are multiple edges with the same weight, any of them can be selected first.

(2) Let $v.parent$ denote a parent node of a node $v$ in a tree structure. Assume $v.parent = v$ when $v$ is a root. Express the tree $T$ shown in Fig. 2 in the format of $\{(v_i, v_i.parent)\}, i = 1, 2, 3, 4$, where the root of $T$ is $v_2$.

(3) Fill in the blank $\fbox{(c)}$ to complete Algorithm 2.

(4) The computing efficiency can be improved when the line 14 in Algorithm 2 is replaced with $v.parent = \textsc{FindSet}(v.parent)$. Explain the reason. You may use diagrams.

<figure style="text-align:center;">
  <img src="https://raw.githubusercontent.com/Myyura/the_kai_project_assets/main/kakomonn/kyoto_university/informatics/ist_202508_kiso_f2_2_p3.png" width="500" alt=""/>
  <img src="https://raw.githubusercontent.com/Myyura/the_kai_project_assets/main/kakomonn/kyoto_university/informatics/ist_202508_kiso_f2_2_p4.png" width="300" alt=""/>
</figure>