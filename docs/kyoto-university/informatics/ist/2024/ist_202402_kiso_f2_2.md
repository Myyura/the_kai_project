---
sidebar_label: "2024年2月実施 基礎科目 F2-2"
tags:
  - Kyoto-University
---
# 京都大学 情報学研究科 知能情報学専攻 2024年2月実施 専門科目 F2-2

## **Author**

[itsuitsuki](https://github.com/itsuitsuki)

## **Description (English)**

We represent an array $P$ of length $m$, whose elements are alphabet characters. We call $P$ a pattern. An element of $P$ can be accessed by $P[i]$, where $1 \le i \le m$ is an index. $P[s : t]$ denotes a contiguous subarray of $P$ starting from index $s$ to $t$ inclusively, where $1 \le s \le t \le m$. $P_h$ denotes the $h$-character prefix $P[1 : h]$ of $P$, while $P_0$ is the empty string $\varepsilon$ and $P_m = P = P[1 : m]$. The *prefix function* for a pattern $P$ returns an array $\pi$ of length $m$, such that each element with an index $1 \le q \le m$ is computed by
$$
\pi[q] = \max\{k \mid k < q \text{ and } P_k \sqsupset P_q\},
$$
where $P_k \sqsupset P_q$ denotes that $P_k$ is a suffix of $P_q$. That is, $\pi[q]$ is the length of the longest prefix of $P_q$ that is also a proper suffix of $P_q$. Note that a proper suffix cannot be the whole string.

**(1)** Compute the results of the prefix function $\pi[1], \pi[2], ..., \pi[11]$ for the pattern `aabaacaabaa`.

**(2)** Algorithm 1 is a pseudo-code of an algorithm for computing the results of the prefix function $\pi$ for a pattern $P$. Fill the blanks (a), (b), and (c).

---

**Algorithm 1** COMPUTE-PREFIX-FUNCTION($P$)

$m = P.length$

let $\pi$ be a new array for keeping the results of the prefix function

$\pi[1] = 0$

$k = 0$

**for** $q = 2$ to $m$ **do**

$\quad$ **while** $k > 0$ and $P[k + 1] \neq P[q]$ **do**

$\qquad$ $\fbox{(a)}$

$\quad$ **end while**

$\quad$ **if** $P[k + 1] == P[q]$ **then**

$\qquad$ $\fbox{(b)}$

$\quad$ **end if**

$\quad$ $\fbox{(c)}$

**end for**

**return** $\pi$

---

We represent an array $T$ of length $n$ and an array $P$ of length $m \le n$. The elements of both $T$ and $P$ are alphabet characters. We call $T$ a text and $P$ a pattern. We say that a pattern $P$ occurs with a shift $s$ in a text $T$ if $0 \le s \le n - m$ and $T[s + 1 : s + m] == P[1 : m]$ (that is, if $T[s + j] == P[j]$, for $1 \le j \le m$). The string-matching problem is the problem of finding all shifts with which a given pattern $P$ occurs in a given text $T$.

**(3)** Algorithm 2 is a pseudo-code of an algorithm for the string-matching problem utilizing the results of the prefix function computed with Algorithm 1. Fill the blanks (d), (e), and (f).

---

**Algorithm 2** STRING-MATCHING($T, P$)

$n = T.length$

$m = P.length$

$\pi = \text{COMPUTE-PREFIX-FUNCTION}(P)$

$q = 0$

**for** $i = 1$ to $n$ **do**

$\quad$ **while** $q > 0$ and $P[q + 1] \neq T[i]$ **do**

$\qquad$ $\fbox{(d)}$

$\quad$ **end while**

$\quad$ **if** $P[q + 1] == T[i]$ **then**

$\qquad$ $\fbox{(e)}$

$\quad$ **end if**

$\quad$ **if** $q == m$ **then**

$\qquad$ print "Pattern occurs with shift" $i - m$

$\qquad$ $\fbox{(f)}$

$\quad$ **end if**

**end for**

---

**(4)** Show the time complexity of Algorithm 2 with reasons.

